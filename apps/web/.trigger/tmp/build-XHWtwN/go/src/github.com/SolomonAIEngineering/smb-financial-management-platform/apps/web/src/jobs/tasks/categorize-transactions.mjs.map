{
  "version": 3,
  "sources": ["../../../../../../../../../../../../../src/jobs/tasks/categorize-transactions.ts"],
  "sourcesContent": ["import { TransactionCategory } from '@prisma/client';\nimport { cronTrigger } from '@trigger.dev/sdk';\n\nimport { prisma } from '@/server/db';\n\nimport { client } from '../client';\n\n/**\n * This job identifies transactions that need categorization and applies\n * auto-categorization based on patterns and merchant names.\n */\nexport const categorizationJob = client.defineJob({\n  id: 'categorize-transactions-job',\n  name: 'Categorize Transactions',\n  trigger: cronTrigger({\n    cron: '0 3 * * *', // Run daily at 3 AM\n  }),\n  version: '1.0.0',\n  run: async (payload, io) => {\n    await io.logger.info('Starting transaction categorization job');\n\n    // Get transactions that need categorization\n    const uncategorizedTransactions = await io.runTask(\n      'get-uncategorized-transactions',\n      async () => {\n        return await prisma.transaction.findMany({\n          take: 1000, // Process in batches\n          where: {\n            category: null,\n            // Only process transactions from the last 90 days\n            date: { gte: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) },\n          },\n        });\n      }\n    );\n\n    await io.logger.info(\n      `Found ${uncategorizedTransactions.length} transactions to categorize`\n    );\n\n    // Process each transaction\n    let categorized = 0;\n\n    for (const transaction of uncategorizedTransactions) {\n      await io.runTask(`categorize-transaction-${transaction.id}`, async () => {\n        // Apply auto-categorization logic\n        const category = categorizeTxByName(\n          transaction.name,\n          transaction.merchantName\n        );\n\n        if (category) {\n          await prisma.transaction.update({\n            data: {\n              category,\n              // You could also assign a subcategory here\n            },\n            where: { id: transaction.id },\n          });\n          categorized++;\n        }\n      });\n    }\n\n    // Identify recurring transactions\n    await io.runTask('identify-recurring-transactions', async () => {\n      // Find potential recurring transactions (similar amounts, same merchant)\n      const potentialRecurring = await prisma.$queryRaw`\n          SELECT \n            \"merchantName\", \n            ROUND(\"amount\"::numeric, 2) as rounded_amount,\n            COUNT(*) as occurrence_count\n          FROM \"Transaction\"\n          WHERE \n            \"date\" >= NOW() - INTERVAL '90 days'\n            AND \"merchantName\" IS NOT NULL\n          GROUP BY \"merchantName\", ROUND(\"amount\"::numeric, 2)\n          HAVING COUNT(*) >= 2\n          ORDER BY occurrence_count DESC\n          LIMIT 500\n        `;\n\n      // For each potential recurring group, check if the transactions are evenly spaced\n      for (const group of potentialRecurring as any[]) {\n        const transactions = await prisma.transaction.findMany({\n          orderBy: { date: 'asc' },\n          where: {\n            amount: {\n              gte: Number.parseFloat(group.rounded_amount) - 0.01,\n              lte: Number.parseFloat(group.rounded_amount) + 0.01,\n            },\n            date: { gte: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) },\n            merchantName: group.merchantName,\n          },\n        });\n\n        if (transactions.length >= 2) {\n          // Check if transactions are roughly evenly spaced\n          const isRecurring = checkIfRecurring(transactions);\n\n          if (isRecurring) {\n            // Generate a recurrence ID (merchant name + amount)\n            const recurrenceId = `${group.merchantName}-${group.rounded_amount}`;\n\n            // Mark all transactions in this group as recurring\n            for (const tx of transactions) {\n              await prisma.transaction.update({\n                data: {\n                  isRecurring: true,\n                  recurrenceId,\n                },\n                where: { id: tx.id },\n              });\n            }\n          }\n        }\n      }\n    });\n\n    return {\n      categorized,\n      success: true,\n      transactionsProcessed: uncategorizedTransactions.length,\n    };\n  },\n});\n\n/** Analyze transaction name and merchant to determine category */\nfunction categorizeTxByName(\n  name: string,\n  merchantName: string | null\n): TransactionCategory | null {\n  const searchText = (merchantName || name).toLowerCase();\n\n  // Simple categorization rule set\n  // In a production app, this would be more sophisticated, possibly using ML\n  if (/payroll|salary|deposit|direct deposit/i.test(searchText)) {\n    return TransactionCategory.INCOME;\n  }\n  if (/transfer|zelle|venmo|paypal|cash app/i.test(searchText)) {\n    return TransactionCategory.TRANSFER;\n  }\n  if (/mortgage|loan|lending|payment/i.test(searchText)) {\n    return TransactionCategory.LOAN_PAYMENTS;\n  }\n  if (/fee|service charge|maintenance|overdraft/i.test(searchText)) {\n    return TransactionCategory.BANK_FEES;\n  }\n  if (\n    /netflix|spotify|hulu|disney|cinema|movie|entertainment/i.test(searchText)\n  ) {\n    return TransactionCategory.ENTERTAINMENT;\n  }\n  if (\n    /restaurant|doordash|uber eats|grubhub|mcdonald|starbucks|dunkin|grocery|food/i.test(\n      searchText\n    )\n  ) {\n    return TransactionCategory.FOOD_AND_DRINK;\n  }\n  if (\n    /amazon|walmart|target|costco|best buy|ebay|etsy|store|shop/i.test(\n      searchText\n    )\n  ) {\n    return TransactionCategory.GENERAL_MERCHANDISE;\n  }\n  if (\n    /home depot|lowe|improvement|repair|furniture|bed bath/i.test(searchText)\n  ) {\n    return TransactionCategory.HOME_IMPROVEMENT;\n  }\n  if (\n    /doctor|medical|pharmacy|hospital|clinic|health|dental/i.test(searchText)\n  ) {\n    return TransactionCategory.MEDICAL;\n  }\n  if (/gym|fitness|salon|barber|spa|beauty/i.test(searchText)) {\n    return TransactionCategory.PERSONAL_CARE;\n  }\n  if (/service|cleaning|repair|maintenance/i.test(searchText)) {\n    return TransactionCategory.GENERAL_SERVICES;\n  }\n  if (/government|tax|irs|dmv|court|donation|charity/i.test(searchText)) {\n    return TransactionCategory.GOVERNMENT_AND_NON_PROFIT;\n  }\n  if (/uber|lyft|taxi|parking|gas|fuel|transit|subway|bus/i.test(searchText)) {\n    return TransactionCategory.TRANSPORTATION;\n  }\n  if (\n    /hotel|airbnb|airline|flight|travel|vacation|expedia|trip/i.test(searchText)\n  ) {\n    return TransactionCategory.TRAVEL;\n  }\n  if (\n    /electric|water|gas|utility|internet|phone|cable|bill/i.test(searchText)\n  ) {\n    return TransactionCategory.UTILITIES;\n  }\n\n  // If we can't categorize it, return null\n  return null;\n}\n\n/**\n * Check if a set of transactions appears to be recurring This is a simple\n * implementation that checks if transactions are roughly evenly spaced\n */\nfunction checkIfRecurring(transactions: any[]): boolean {\n  if (transactions.length < 2) {\n    return false;\n  }\n\n  // Calculate the average interval between transactions in days\n  let totalInterval = 0;\n  const intervals: number[] = [];\n\n  for (let i = 1; i < transactions.length; i++) {\n    const currentDate = new Date(transactions[i].date);\n    const prevDate = new Date(transactions[i - 1].date);\n    const intervalDays =\n      (currentDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24);\n\n    intervals.push(intervalDays);\n    totalInterval += intervalDays;\n  }\n\n  const avgInterval = totalInterval / intervals.length;\n\n  // Check if transactions are roughly evenly spaced\n  // (variance less than 20% of the average interval)\n  let variance = 0;\n\n  for (const interval of intervals) {\n    variance += Math.pow(interval - avgInterval, 2);\n  }\n\n  variance /= intervals.length;\n\n  // Return true if average interval is between 25-35 days (monthly) or 13-16 days (bi-weekly)\n  // and variance is low\n  return (\n    ((avgInterval >= 25 && avgInterval <= 35) ||\n      (avgInterval >= 13 && avgInterval <= 16)) &&\n    Math.sqrt(variance) < 0.2 * avgInterval\n  );\n}\n"],
  "mappings": "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",
  "names": []
}
