{
  "version": 3,
  "sources": ["../../../../../../../../../../../../../../src/jobs/tasks/transactions/analyze-spending.ts"],
  "sourcesContent": ["import { cronTrigger } from '@trigger.dev/sdk';\nimport { endOfMonth, format, startOfMonth, subMonths } from 'date-fns';\n\nimport { prisma } from '@/server/db';\n\nimport { client } from '../../client';\n\n/**\n * This job analyzes users' spending patterns and identifies trends, calculating\n * monthly statistics and generating insights.\n */\nexport const analyzeSpendingJob = client.defineJob({\n  id: 'analyze-spending-patterns-job',\n  name: 'Analyze Spending Patterns',\n  trigger: cronTrigger({\n    cron: '0 2 * * *', // Every day at 2 AM\n  }),\n  version: '1.0.0',\n  run: async (payload, io) => {\n    await io.logger.info('Starting spending pattern analysis');\n\n    // Get active users with transactions\n    const activeUsers = await io.runTask('get-active-users', async () => {\n      return await prisma.user.findMany({\n        select: {\n          id: true,\n        },\n        take: 100, // Process in batches\n        where: {\n          transactions: {\n            some: {\n              date: {\n                gte: subMonths(new Date(), 3), // Active in last 3 months\n              },\n            },\n          },\n        },\n      });\n    });\n\n    await io.logger.info(`Found ${activeUsers.length} active users to analyze`);\n\n    // Process each user\n    // for (const user of activeUsers) {\n    //   await io.runTask(`analyze-user-${user.id}`, async () => {\n    //     try {\n    //       // Get last 3 months\n    //       const today = new Date();\n    //       const threeMonthsAgo = subMonths(today, 3);\n\n    //       // Monthly spending analysis\n    //       const monthlyStats = await generateMonthlyStats(\n    //         user.id,\n    //         threeMonthsAgo,\n    //         today\n    //       );\n\n    //       // Category spending analysis\n    //       const categoryStats = await generateCategoryStats(\n    //         user.id,\n    //         threeMonthsAgo,\n    //         today\n    //       );\n\n    //       // Identify top merchants\n    //       const topMerchants = await getTopMerchants(\n    //         user.id,\n    //         threeMonthsAgo,\n    //         today\n    //       );\n\n    //       // Calculate average transaction size\n    //       const avgTransactionSize = await getAverageTransactionSize(\n    //         user.id,\n    //         threeMonthsAgo,\n    //         today\n    //       );\n\n    //       // Store insights for the user\n    //       await prisma.spendingInsight.create({\n    //         data: {\n    //           userId: user.id,\n    //           startDate: threeMonthsAgo,\n    //           endDate: today,\n    //           timeframe: 'MONTH',\n    //           year: today.getFullYear(),\n    //           month: today.getMonth() + 1,\n    //           totalTransactions: avgTransactionSize.count,\n    //           totalSpending: monthlyStats.reduce((sum, month) => sum + month.spending, 0),\n    //           avgTransactionSize: avgTransactionSize.avgAmount,\n    //           categoryStats: categoryStats,\n    //           merchantStats: { topMerchants },\n    //           spendingTrend: monthlyStats.length >= 2\n    //             ? ((monthlyStats.at(-1).spending - monthlyStats.at(-2).spending) / monthlyStats.at(-2).spending) * 100\n    //             : null,\n    //           incomeTotal: monthlyStats.reduce((sum, month) => sum + month.income, 0),\n    //           incomeTrend: monthlyStats.length >= 2\n    //             ? ((monthlyStats.at(-1).income - monthlyStats.at(-2).income) / monthlyStats.at(-2).income) * 100\n    //             : null\n    //         },\n    //       });\n    //     } catch (error) {\n    //       const errorMessage =\n    //         error instanceof Error ? error.message : String(error);\n    //       await io.logger.error(\n    //         `Error analyzing spending for user ${user.id}: ${errorMessage}`\n    //       );\n    //     }\n    //   });\n    // }\n\n    return {\n      usersAnalyzed: activeUsers.length,\n    };\n  },\n});\n\n/** Generate monthly spending statistics */\nasync function generateMonthlyStats(\n  userId: string,\n  startDate: Date,\n  endDate: Date\n) {\n  type MonthStat = {\n    income: number;\n    month: string;\n    netCashflow: number;\n    spending: number;\n  };\n\n  const months: MonthStat[] = [];\n  let currentDate = startDate;\n\n  while (currentDate < endDate) {\n    const monthStart = startOfMonth(currentDate);\n    const monthEnd = endOfMonth(currentDate);\n    const monthLabel = format(currentDate, 'MMM yyyy');\n\n    // Get spending for this month\n    const spending = await prisma.transaction.aggregate({\n      _sum: {\n        amount: true,\n      },\n      where: {\n        amount: { gt: 0 },\n        date: {\n          gte: monthStart,\n          lte: monthEnd,\n        },\n        userId,\n      },\n    });\n\n    // Get income for this month\n    const income = await prisma.transaction.aggregate({\n      _sum: {\n        amount: true,\n      },\n      where: {\n        amount: { lt: 0 }, // Negative amounts are income in Plaid\n        date: {\n          gte: monthStart,\n          lte: monthEnd,\n        },\n        userId,\n      },\n    });\n\n    months.push({\n      income: Math.abs(income._sum.amount || 0),\n      month: monthLabel,\n      netCashflow:\n        Math.abs(income._sum.amount || 0) - (spending._sum.amount || 0),\n      spending: spending._sum.amount || 0,\n    });\n\n    // Move to next month\n    currentDate = new Date(currentDate.setMonth(currentDate.getMonth() + 1));\n  }\n\n  return months;\n}\n\n/** Generate category spending statistics */\nasync function generateCategoryStats(\n  userId: string,\n  startDate: Date,\n  endDate: Date\n) {\n  // Get spending by category\n  const categoryStats = await prisma.transaction.groupBy({\n    _sum: {\n      amount: true,\n    },\n    by: ['category'],\n    where: {\n      amount: { gt: 0 },\n      category: { not: null },\n      date: {\n        gte: startDate,\n        lte: endDate,\n      },\n      userId,\n    },\n  });\n\n  // Get total spending\n  const totalSpending = await prisma.transaction.aggregate({\n    _sum: {\n      amount: true,\n    },\n    where: {\n      amount: { gt: 0 },\n      date: {\n        gte: startDate,\n        lte: endDate,\n      },\n      userId,\n    },\n  });\n\n  return categoryStats.map((cat) => ({\n    amount: cat._sum.amount || 0,\n    category: cat.category,\n    percentage:\n      ((cat._sum.amount || 0) / (totalSpending._sum.amount || 1)) * 100,\n  }));\n}\n\n/** Get top merchants by spending */\nasync function getTopMerchants(userId: string, startDate: Date, endDate: Date) {\n  const merchants = await prisma.transaction.groupBy({\n    _sum: {\n      amount: true,\n    },\n    by: ['merchantName'],\n    orderBy: {\n      _sum: {\n        amount: 'desc',\n      },\n    },\n    take: 10,\n    where: {\n      amount: { gt: 0 },\n      date: {\n        gte: startDate,\n        lte: endDate,\n      },\n      merchantName: { not: null },\n      userId,\n    },\n  });\n\n  return merchants.map((merchant) => ({\n    amount: merchant._sum.amount || 0,\n    merchantName: merchant.merchantName,\n  }));\n}\n\n/** Calculate average transaction size */\nasync function getAverageTransactionSize(\n  userId: string,\n  startDate: Date,\n  endDate: Date\n) {\n  const result = await prisma.transaction.aggregate({\n    _avg: {\n      amount: true,\n    },\n    _count: true,\n    where: {\n      amount: { gt: 0 },\n      date: {\n        gte: startDate,\n        lte: endDate,\n      },\n      userId,\n    },\n  });\n\n  return {\n    avgAmount: result._avg.amount || 0,\n    count: result._count,\n  };\n}\n\n/** Generate insights text based on the financial data */\nfunction generateInsightsText(\n  monthlyStats: any[],\n  categoryStats: any[],\n  topMerchants: any[]\n) {\n  const insights: string[] = [];\n\n  // Monthly trend insights\n  if (monthlyStats.length >= 2) {\n    const lastMonth = monthlyStats.at(-1);\n    const prevMonth = monthlyStats.at(-2);\n\n    if (lastMonth.spending > prevMonth.spending) {\n      const increase = (\n        ((lastMonth.spending - prevMonth.spending) / prevMonth.spending) *\n        100\n      ).toFixed(1);\n      insights.push(\n        `Your spending increased by ${increase}% compared to last month.`\n      );\n    } else {\n      const decrease = (\n        ((prevMonth.spending - lastMonth.spending) / prevMonth.spending) *\n        100\n      ).toFixed(1);\n      insights.push(\n        `Your spending decreased by ${decrease}% compared to last month.`\n      );\n    }\n  }\n  // Category insights\n  if (categoryStats.length > 0) {\n    const topCategory = categoryStats.sort((a, b) => b.amount - a.amount)[0];\n    insights.push(\n      `Your top spending category is ${topCategory.category} at ${topCategory.percentage.toFixed(1)}% of your total spending.`\n    );\n  }\n  // Merchant insights\n  if (topMerchants.length > 0) {\n    insights.push(\n      `You spent the most at ${topMerchants[0].merchantName} in the last 3 months.`\n    );\n  }\n\n  return insights;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AACA,sBAA4D;AAUrD,IAAM,qBAAqB,OAAO,UAAU;AAAA,EACjD,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,SAAS,YAAY;AAAA,IACnB,MAAM;AAAA;AAAA,EACR,CAAC;AAAA,EACD,SAAS;AAAA,EACT,KAAK,OAAO,SAAS,OAAO;AAC1B,UAAM,GAAG,OAAO,KAAK,oCAAoC;AAGzD,UAAM,cAAc,MAAM,GAAG,QAAQ,oBAAoB,YAAY;AACnE,aAAO,MAAM,OAAO,KAAK,SAAS;AAAA,QAChC,QAAQ;AAAA,UACN,IAAI;AAAA,QACN;AAAA,QACA,MAAM;AAAA;AAAA,QACN,OAAO;AAAA,UACL,cAAc;AAAA,YACZ,MAAM;AAAA,cACJ,MAAM;AAAA,gBACJ,SAAK,2BAAU,oBAAI,KAAK,GAAG,CAAC;AAAA;AAAA,cAC9B;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAED,UAAM,GAAG,OAAO,KAAK,SAAS,YAAY,MAAM,0BAA0B;AAuE1E,WAAO;AAAA,MACL,eAAe,YAAY;AAAA,IAC7B;AAAA,EACF;AACF,CAAC;",
  "names": []
}
