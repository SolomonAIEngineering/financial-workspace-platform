{
  "version": 3,
  "sources": ["../../../../../../../../../../../../../../../src/jobs/tasks/bank/scheduler/expiring-scheduler.ts"],
  "sourcesContent": ["import { BankConnectionStatus } from '@prisma/client';\nimport { cronTrigger } from '@trigger.dev/sdk';\nimport { differenceInDays, subDays } from 'date-fns';\n\nimport { prisma } from '@/server/db';\n\nimport { client } from '../../../client';\n\n/**\n * This job runs on a schedule to find bank connections that might be\n * approaching their expiration date and notifies users to take action. This\n * helps maintain continuous access to financial data.\n */\nexport const expiringSchedulerJob = client.defineJob({\n  id: 'expiring-scheduler-job',\n  name: 'Expiring Connections Scheduler',\n  trigger: cronTrigger({\n    cron: '0 10 * * *', // Run daily at 10 AM\n  }),\n  version: '1.0.0',\n  run: async (payload, io) => {\n    await io.logger.info('Starting expiring connections scheduler');\n\n    // Plaid tokens typically expire after 30 days of inactivity\n    // We'll proactively notify users of connections that haven't been used in 20+ days\n    const expiringThreshold = subDays(new Date(), 20);\n\n    // Find potentially expiring connections\n    const expiringConnections = await io.runTask(\n      'find-expiring-connections',\n      async () => {\n        return await prisma.bankConnection.findMany({\n          include: {\n            accounts: {\n              select: {\n                id: true,\n                name: true,\n              },\n              where: {\n                enabled: true,\n              },\n            },\n            user: {\n              select: {\n                id: true,\n                email: true,\n                name: true,\n              },\n            },\n          },\n          where: {\n            lastAccessedAt: {\n              lt: expiringThreshold,\n            },\n            // Only get connections that haven't been notified about expiring in the last 7 days\n            lastExpiryNotifiedAt: {\n              lt: subDays(new Date(), 7),\n            },\n            status: BankConnectionStatus.ACTIVE,\n          },\n        });\n      }\n    );\n\n    await io.logger.info(\n      `Found ${expiringConnections.length} potentially expiring connections`\n    );\n\n    // Process each expiring connection\n    let notificationsSent = 0;\n\n    for (const connection of expiringConnections) {\n      await io.runTask(`process-expiring-${connection.id}`, async () => {\n        // Skip if no email or no active accounts\n        if (!connection.user.email || connection.accounts.length === 0) {\n          return;\n        }\n\n        const daysInactive = differenceInDays(\n          new Date(),\n          new Date(connection.lastAccessedAt || new Date())\n        );\n        const daysUntilExpiry = 30 - daysInactive;\n\n        // Send notification to user\n        await client.sendEvent({\n          name: 'expiring-notification-trigger',\n          payload: {\n            accountCount: connection.accounts.length,\n            connectionId: connection.id,\n            daysInactive,\n            daysUntilExpiry,\n            email: connection.user.email,\n            institutionName: connection.institutionName,\n            name: connection.user.name,\n            userId: connection.user.id,\n          },\n        });\n\n        // Update last notified timestamp\n        await prisma.bankConnection.update({\n          data: {\n            expiryNotificationCount: { increment: 1 },\n            lastExpiryNotifiedAt: new Date(),\n          },\n          where: { id: connection.id },\n        });\n\n        // Record this activity\n        await prisma.userActivity.create({\n          data: {\n            detail: `Expiring connection notification for ${connection.institutionName}`,\n            metadata: {\n              connectionId: connection.id,\n              daysInactive,\n              daysUntilExpiry,\n            },\n            type: 'NOTIFICATION_SENT',\n            userId: connection.user.id,\n          },\n        });\n\n        notificationsSent++;\n      });\n    }\n\n    // For connections that have likely already expired (no activity in 30+ days),\n    // mark them as requiring attention\n    const expiredConnections = await io.runTask(\n      'find-expired-connections',\n      async () => {\n        return await prisma.bankConnection.findMany({\n          where: {\n            lastAccessedAt: {\n              lt: subDays(new Date(), 30),\n            },\n            status: BankConnectionStatus.ACTIVE,\n          },\n        });\n      }\n    );\n\n    let markedForAttention = 0;\n\n    for (const connection of expiredConnections) {\n      await io.runTask(`mark-expired-${connection.id}`, async () => {\n        // Mark as requiring attention\n        await prisma.bankConnection.update({\n          data: {\n            errorMessage: 'Connection may have expired due to inactivity',\n            status: BankConnectionStatus.REQUIRES_ATTENTION,\n          },\n          where: { id: connection.id },\n        });\n\n        markedForAttention++;\n      });\n    }\n\n    await io.logger.info(\n      `Completed scheduler run. Sent ${notificationsSent} notifications and marked ${markedForAttention} connections as requiring attention`\n    );\n\n    return {\n      connectionsProcessed: expiringConnections.length,\n      markedForAttention,\n      notificationsSent,\n    };\n  },\n});\n"],
  "mappings": "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",
  "names": []
}
