{
  "version": 3,
  "sources": ["../../../../../../../../../../../../../src/jobs/tasks/sync-transactions.ts", "../../../../../../../../../../../../../src/jobs/utils/helpers.ts"],
  "sourcesContent": ["import { type BankConnection, SyncStatus } from '@prisma/client';\nimport { cronTrigger, eventTrigger } from '@trigger.dev/sdk';\nimport { z } from 'zod';\n\nimport { prisma } from '@/server/db';\nimport {\n  getAccounts,\n  getItemDetails,\n  getTransactions,\n} from '@/server/services/plaid';\n\nimport { client } from '../client';\nimport {\n  getConnectionsForSync,\n  getTransactionDateRange,\n  updateConnectionSyncStatus,\n} from '../utils/helpers';\n\n// Define the job for syncing all user transactions\nexport const syncAllTransactionsJob = client.defineJob({\n  id: 'sync-all-transactions-job',\n  name: 'Sync All Transactions',\n  trigger: cronTrigger({\n    cron: '0 */4 * * *', // Every 4 hours\n  }),\n  version: '1.0.0',\n  run: async (payload, io) => {\n    await io.logger.info('Starting transaction sync for all connections');\n\n    // Get all connections that need syncing\n    const connections = await io.runTask('get-connections', async () => {\n      return await getConnectionsForSync();\n    });\n\n    await io.logger.info(`Found ${connections.length} connections to sync`);\n\n    // Process each connection\n    for (const connection of connections) {\n      await io.runTask(`sync-connection-${connection.id}`, async () => {\n        try {\n          await updateConnectionSyncStatus(connection.id, SyncStatus.SYNCING);\n          await syncConnectionTransactions(connection, io);\n          await updateConnectionSyncStatus(connection.id, SyncStatus.IDLE);\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : String(error);\n          await io.logger.error(\n            `Error syncing connection ${connection.id}: ${errorMessage}`\n          );\n          await updateConnectionSyncStatus(\n            connection.id,\n            SyncStatus.FAILED,\n            errorMessage\n          );\n        }\n      });\n    }\n\n    return { connectionsProcessed: connections.length, success: true };\n  },\n});\n\n// Define the job for syncing a single user's transactions\nexport const syncUserTransactionsJob = client.defineJob({\n  id: 'sync-user-transactions-job',\n  name: 'Sync User Transactions',\n  // This job is triggered manually or via API\n  trigger: eventTrigger({\n    name: 'manual-sync-transactions',\n    schema: z.object({\n      userId: z.string(),\n    }),\n  }),\n  version: '1.0.0',\n  run: async (payload, io) => {\n    const { userId } = payload;\n    await io.logger.info(`Starting transaction sync for user ${userId}`);\n\n    // Get user's connections\n    const connections = await io.runTask('get-user-connections', async () => {\n      return await prisma.bankConnection.findMany({\n        where: {\n          status: {\n            not: 'ERROR',\n          },\n          userId,\n        },\n      });\n    });\n\n    await io.logger.info(\n      `Found ${connections.length} connections for user ${userId}`\n    );\n\n    // Process each connection\n    for (const connection of connections) {\n      await io.runTask(`sync-connection-${connection.id}`, async () => {\n        try {\n          await updateConnectionSyncStatus(connection.id, SyncStatus.SYNCING);\n          await syncConnectionTransactions(connection, io);\n          await updateConnectionSyncStatus(connection.id, SyncStatus.IDLE);\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : String(error);\n          await io.logger.error(\n            `Error syncing connection ${connection.id}: ${errorMessage}`\n          );\n          await updateConnectionSyncStatus(\n            connection.id,\n            SyncStatus.FAILED,\n            errorMessage\n          );\n        }\n      });\n    }\n\n    return { connectionsProcessed: connections.length, success: true, userId };\n  },\n});\n\n/** Helper function to sync transactions for a specific connection */\nasync function syncConnectionTransactions(connection: BankConnection, io: any) {\n  const { endDate, startDate } = getTransactionDateRange(30);\n\n  // Check item status\n  const itemDetails = await io.runTask(\n    `check-item-status-${connection.id}`,\n    async () => await getItemDetails(connection.accessToken)\n  );\n\n  // Get accounts for this connection\n  const bankAccounts = await io.runTask(\n    `get-bank-accounts-${connection.id}`,\n    async () => {\n      return await prisma.bankAccount.findMany({\n        where: { bankConnectionId: connection.id },\n      });\n    }\n  );\n\n  // Update account balances\n  const updatedAccounts = await io.runTask(\n    `update-account-balances-${connection.id}`,\n    async () => {\n      const plaidAccounts = await getAccounts(connection.accessToken);\n\n      // Update each account with new balance information\n      for (const plaidAccount of plaidAccounts) {\n        const bankAccount = bankAccounts.find(\n          (account) => account.plaidAccountId === plaidAccount.plaidAccountId\n        );\n\n        if (bankAccount) {\n          await prisma.bankAccount.update({\n            data: {\n              availableBalance: plaidAccount.availableBalance,\n              balanceLastUpdated: new Date(),\n              currentBalance: plaidAccount.currentBalance,\n              limit: plaidAccount.limit,\n            },\n            where: { id: bankAccount.id },\n          });\n        }\n      }\n\n      return plaidAccounts;\n    }\n  );\n\n  // Sync transactions\n  const transactionResults = await io.runTask(\n    `sync-transactions-${connection.id}`,\n    async () => {\n      // Get transactions from Plaid\n      const transactions = await getTransactions(\n        connection.accessToken,\n        connection,\n        bankAccounts,\n        startDate,\n        endDate\n      );\n\n      // Process each transaction\n      let created = 0;\n      let updated = 0;\n      const skipped = 0;\n\n      for (const transaction of transactions) {\n        // Check if transaction already exists\n        const existingTransaction = await prisma.transaction.findUnique({\n          where: { plaidTransactionId: transaction.plaidTransactionId },\n        });\n\n        if (existingTransaction) {\n          // Update existing transaction\n          await prisma.transaction.update({\n            data: {\n              amount: transaction.amount,\n              category: transaction.category,\n              date: transaction.date,\n              merchantName: transaction.merchantName,\n              name: transaction.name,\n              pending: transaction.pending,\n              subCategory: transaction.subCategory,\n            },\n            where: { id: existingTransaction.id },\n          });\n          updated++;\n        } else {\n          // Create new transaction\n          await prisma.transaction.create({\n            data: transaction,\n          });\n          created++;\n        }\n      }\n\n      return { created, skipped, updated };\n    }\n  );\n\n  // Calculate account statistics\n  await io.runTask(\n    `calculate-account-statistics-${connection.id}`,\n    async () => {\n      for (const account of bankAccounts) {\n        // Calculate monthly income\n        const monthlyIncome = await prisma.transaction.aggregate({\n          _sum: { amount: true },\n          where: {\n            amount: { lt: 0 }, // Income is negative in Plaid (money coming in)\n            bankAccountId: account.id,\n            date: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }, // Last 30 days\n          },\n        });\n\n        // Calculate monthly spending\n        const monthlySpending = await prisma.transaction.aggregate({\n          _sum: { amount: true },\n          where: {\n            amount: { gt: 0 }, // Spending is positive in Plaid (money going out)\n            bankAccountId: account.id,\n            date: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }, // Last 30 days\n          },\n        });\n\n        // Calculate average balance\n        const averageBalance = account.currentBalance;\n\n        // Update account with statistics\n        await prisma.bankAccount.update({\n          data: {\n            averageBalance: averageBalance,\n            monthlyIncome: Math.abs(monthlyIncome._sum.amount || 0),\n            monthlySpending: monthlySpending._sum.amount || 0,\n          },\n          where: { id: account.id },\n        });\n      }\n    }\n  );\n\n  return {\n    accountsUpdated: updatedAccounts.length,\n    transactions: transactionResults,\n  };\n}\n", "import {\n  type BankConnection,\n  BankConnectionStatus,\n  SyncStatus,\n} from '@prisma/client';\nimport { format, subDays } from 'date-fns';\n\nimport { prisma } from '@/server/db';\n\n/**\n * Get connections that need to be synced This can be used by scheduled jobs to\n * identify connections that need refreshing\n */\nexport async function getConnectionsForSync(): Promise<BankConnection[]> {\n  const connections = await prisma.bankConnection.findMany({\n    orderBy: {\n      lastSyncedAt: 'asc', // Sync oldest first\n    },\n    take: 50, // Process in batches of 50\n    where: {\n      OR: [\n        { lastSyncedAt: null }, // Never synced\n        {\n          lastSyncedAt: {\n            // Last sync was more than 12 hours ago\n            lt: new Date(Date.now() - 12 * 60 * 60 * 1000),\n          },\n        },\n        { syncStatus: SyncStatus.SCHEDULED }, // Explicitly scheduled for sync\n      ],\n      status: {\n        not: BankConnectionStatus.ERROR,\n      },\n    },\n  });\n\n  return connections;\n}\n\n/** Update a connection's sync status */\nexport async function updateConnectionSyncStatus(\n  connectionId: string,\n  status: SyncStatus,\n  error?: string\n): Promise<void> {\n  await prisma.bankConnection.update({\n    data: {\n      errorMessage: error || undefined,\n      lastSyncedAt: status === SyncStatus.SYNCING ? undefined : new Date(),\n      status: error ? BankConnectionStatus.ERROR : undefined,\n      syncStatus: status,\n    },\n    where: {\n      id: connectionId,\n    },\n  });\n}\n\n/** Format a date for Plaid API */\nexport function formatDateForPlaid(date: Date): string {\n  return format(date, 'yyyy-MM-dd');\n}\n\n/**\n * Get start and end dates for transaction sync By default, fetches last 30 days\n * of transactions\n */\nexport function getTransactionDateRange(days = 30): {\n  endDate: string;\n  startDate: string;\n} {\n  const endDate = new Date();\n  const startDate = subDays(endDate, days);\n\n  return {\n    endDate: formatDateForPlaid(endDate),\n    startDate: formatDateForPlaid(startDate),\n  };\n}\n\n/** Chunk an array into smaller arrays Used for batch processing */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  const chunked: T[][] = [];\n  let index = 0;\n\n  while (index < array.length) {\n    chunked.push(array.slice(index, index + size));\n    index += size;\n  }\n\n  return chunked;\n}\n"],
  "mappings": "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",
  "names": ["import_client"]
}
