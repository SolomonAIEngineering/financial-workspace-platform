{
  "version": 3,
  "sources": ["../../../../../../../../../../../../../../../src/jobs/tasks/bank/notifications/transactions.ts"],
  "sourcesContent": ["import { eventTrigger } from '@trigger.dev/sdk';\nimport { subDays } from 'date-fns';\n\nimport { prisma } from '@/server/db';\n\nimport { client } from '../../../client';\n\n/**\n * This job sends notifications to users about new transactions It groups\n * transactions by account and creates summaries\n */\nexport const transactionNotificationsJob = client.defineJob({\n  id: 'transaction-notifications-job',\n  name: 'Send Transaction Notifications',\n  trigger: eventTrigger({\n    name: 'sync-transaction-notifications',\n  }),\n  version: '1.0.0',\n  run: async (payload, io) => {\n    const { userId } = payload;\n\n    await io.logger.info(\n      `Starting transaction notifications for user ${userId}`\n    );\n\n    try {\n      // Find user details\n      const user = await io.runTask('get-user', async () => {\n        return await prisma.user.findUnique({\n          select: {\n            id: true,\n            email: true,\n            lastTransactionNotificationAt: true,\n            name: true,\n            notificationsEnabled: true,\n          },\n          where: { id: userId },\n        });\n      });\n\n      if (!user) {\n        await io.logger.error(`User ${userId} not found`);\n\n        throw new Error(`User ${userId} not found`);\n      }\n      // Skip if notifications are disabled\n      if (user.notificationsEnabled === false) {\n        await io.logger.info(\n          `Notifications disabled for user ${userId}, skipping`\n        );\n\n        return {\n          reason: 'Notifications disabled',\n          status: 'skipped',\n        };\n      }\n\n      // Determine the cutoff date for \"new\" transactions\n      const lastNotification =\n        user.lastTransactionNotificationAt || subDays(new Date(), 7);\n\n      // Find new transactions since last notification\n      const transactions = await io.runTask(\n        'get-new-transactions',\n        async () => {\n          return await prisma.transaction.findMany({\n            include: {\n              bankAccount: {\n                select: {\n                  mask: true,\n                  name: true,\n                },\n              },\n            },\n            orderBy: {\n              createdAt: 'desc',\n            },\n            where: {\n              amount: { gt: 0 }, // Only include expenses\n              createdAt: {\n                gt: lastNotification,\n              },\n              pending: false, // Skip pending transactions\n              userId,\n            },\n          });\n        }\n      );\n\n      if (transactions.length === 0) {\n        await io.logger.info(\n          `No new transactions found for user ${userId}, skipping`\n        );\n\n        return {\n          reason: 'No new transactions',\n          status: 'skipped',\n        };\n      }\n\n      await io.logger.info(\n        `Found ${transactions.length} new transactions for user ${userId}`\n      );\n\n      // Group transactions by bank account\n      const accountTransactions = transactions.reduce(\n        (acc, transaction) => {\n          const accountId = transaction.bankAccountId;\n\n          if (!acc[accountId]) {\n            acc[accountId] = {\n              accountMask: transaction.bankAccount?.mask || 'xxxx',\n              accountName: transaction.bankAccount?.name || 'Unknown',\n              total: 0,\n              transactions: [],\n            };\n          }\n\n          acc[accountId].transactions.push(transaction);\n          acc[accountId].total += transaction.amount;\n\n          return acc;\n        },\n        {} as Record<\n          string,\n          {\n            accountMask: string;\n            accountName: string;\n            total: number;\n            transactions: any[];\n          }\n        >\n      );\n\n      // Organize data for the notification\n      const largeTransactions = transactions\n        .filter((t) => t.amount >= 100) // Transactions over $100\n        .sort((a, b) => b.amount - a.amount) // Sort by amount descending\n        .slice(0, 5); // Top 5\n\n      const totalSpent = transactions.reduce((sum, t) => sum + t.amount, 0);\n      const accountSummaries = Object.values(accountTransactions).map(\n        (acct) => ({\n          mask: acct.accountMask,\n          name: acct.accountName,\n          total: acct.total,\n          transactionCount: acct.transactions.length,\n        })\n      );\n\n      // Send the notification\n      if (user.email) {\n        await io.runTask('send-notification', async () => {\n          await client.sendEvent({\n            name: 'send-email',\n            payload: {\n              subject: 'Transaction Summary: New Activity in Your Accounts',\n              template: 'transaction-summary',\n              templateData: {\n                accountSummaries,\n                largeTransactions,\n                name: user.name || 'there',\n                totalSpent,\n                transactionCount: transactions.length,\n                viewAllUrl: `https://yourdomain.com/app/transactions`,\n              },\n              to: user.email,\n            },\n          });\n        });\n      }\n\n      // Update the last notification timestamp\n      await prisma.user.update({\n        data: {\n          lastTransactionNotificationAt: new Date(),\n        },\n        where: { id: userId },\n      });\n\n      // Record this activity\n      await prisma.userActivity.create({\n        data: {\n          detail: `Transaction summary with ${transactions.length} transactions`,\n          metadata: {\n            totalSpent,\n            transactionCount: transactions.length,\n          },\n          type: 'TRANSACTION_NOTIFICATION',\n          userId,\n        },\n      });\n\n      await io.logger.info(`Transaction notifications sent for user ${userId}`);\n\n      return {\n        accountCount: Object.keys(accountTransactions).length,\n        status: 'success',\n        transactionCount: transactions.length,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      await io.logger.error(\n        `Failed to send transaction notifications: ${errorMessage}`\n      );\n\n      throw error;\n    }\n  },\n});\n"],
  "mappings": "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",
  "names": []
}
